{"version":3,"sources":["brains/AudioSourcer.ts","components/HarmonicSeriesDefinition.tsx","brains/AudioMath.ts","components/SineWave.tsx","components/HarmonicSeriesNotes.tsx","assets/SpeakerOn.svg","assets/SpeakerOff.svg","components/NoteBanner.tsx","components/App.tsx","reportWebVitals.ts","index.tsx"],"names":["analyser","audioContext","updateNoteFrequency","HarmonicSeriesDefinition","className","noteStrings","noteFromPitch","frequency","noteNum","Math","log","round","centsOffFromPitch","note","floor","pow","frequencyFromNoteNumber","detuneTypeFromPitch","detune","getNote","noteNumber","SineWave","props","canvasRef","useRef","contextRef","theta","useEffect","canvas","current","width","height","style","context","getContext","draw","clearRect","beginPath","i","y","sin","waves","lineTo","lineWidth","strokeStyle","element","document","getElementById","toString","window","getComputedStyle","color","GetColor","stroke","requestAnimationFrame","ref","HarmonicSeriesNotes","synth","Tone","toDestination","harmonicSeriesElements","elementIteration","seriesElem","map","onClick","triggerAttackRelease","PlayTone","id","mediaStreamSource","buf","Float32Array","audioInitialized","rafID","previousNote","STREAM_CONSTRAINTS","audio","advanced","echoCancellation","autoGainControl","noiseSuppression","error","alert","enableLiveInput","callbackForNoteFrequency","AudioContext","callback","navigator","getUserMedia","e","gotStream","stream","createMediaStreamSource","createAnalyser","fftSize","connect","updatePitch","getFloatTimeDomainData","ac","sampleRate","SIZE","length","rms","val","sqrt","r1","r2","j","abs","x","slice","c","Array","fill","z","d","maxval","maxpos","w","T0","x1","x2","x3","a","autoCorrelate","pitch","detuneType","newNote","webkitRequestAnimationFrame","NoteBanner","useState","hasAudioStarted","setHasAudioStarted","isHover","setIsHover","formattedFrequency","formattedNode","cancelAnimationFrame","console","updateNoteAndFrequency","onMouseEnter","onMouseLeave","speakerOnIcon","src","SpeakerOn","alt","speakerOffIcon","SpeakerOff","getHoveredElement","App","React","setFrequency","setNote","newFrequency","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.e6b964fd.chunk.js","sourcesContent":["import { autoCorrelate, detuneTypeFromPitch, getNote, noteFromPitch } from \"./AudioMath\";\n\nlet mediaStreamSource = null;\nlet analyser: AnalyserNode;\nlet audioContext: AudioContext;\nvar buflen = 2048;\nvar buf = new Float32Array( buflen );\nvar audioInitialized: boolean = false;\nvar rafID: number = 0;\nvar previousNote: string = '';\nlet updateNoteFrequency: (newNote: string, newFrequency: number) => void;\n\nconst initAudio = () => {\n    audioContext = new AudioContext();\n    audioInitialized = true;\n}\n\nconst STREAM_CONSTRAINTS: MediaStreamConstraints = {\n    audio: {\n        advanced: [{\n            echoCancellation: false,\n            autoGainControl: false,\n            noiseSuppression: false,\n        }]\n    }\n}\n\nconst error = () => {\n    alert('Stream generation failed.');\n}\n\nconst getUserMedia = (callback: NavigatorUserMediaSuccessCallback) => {\n    try {\n        navigator.getUserMedia(STREAM_CONSTRAINTS, callback, error);\n    } catch (e) {\n        alert('getUserMedia threw exception :' + e);\n    }\n}\n\nexport const enableLiveInput = (callbackForNoteFrequency: (newNote: string, newFrequency: number) => void) => {\n    if (!audioInitialized) initAudio();\n    updateNoteFrequency = callbackForNoteFrequency;\n    getUserMedia(gotStream);\n}\n\nexport const cancelAudioStream = () => {\n    window.cancelAnimationFrame(rafID);\n    console.log('Audio stream stopped');\n}\n\nconst gotStream = (stream: MediaStream) => {\n    // Create an AudioNode from the stream.\n    mediaStreamSource = audioContext.createMediaStreamSource(stream);\n\n    // Connect it to the destination.\n    analyser = audioContext.createAnalyser();\n    analyser.fftSize = 2048;\n    mediaStreamSource.connect(analyser);\n    updatePitch();\n}\n\nconst updatePitch = () => {\n    analyser.getFloatTimeDomainData( buf );\n\tvar ac = autoCorrelate( buf, audioContext.sampleRate );\n    \n    if (ac !== -1) {\n        const pitch = Math.round(ac);\n        const note = noteFromPitch(pitch);\n\n        // TODO: Find relation between pitch and frequency (hertz)\n        // For now I'm assuming they're the same\n        const detuneType = detuneTypeFromPitch(ac, note);\n        const newNote = `${getNote(note%12)} ${detuneType}`\n        if (previousNote === '' || previousNote !== newNote) {\n            //console.log(`${pitch}Hz - ${newNote}`);\n            previousNote = newNote;\n        }\n        updateNoteFrequency(newNote, pitch);\n    }\n\n    if (!window.requestAnimationFrame) {\n\t\twindow.requestAnimationFrame = window.webkitRequestAnimationFrame;\n    }\n\n    rafID = window.requestAnimationFrame(updatePitch);\n}","import '../style/HarmonicSeriesDefinition.css';\n\nconst HarmonicSeriesDefinition = () => {\n    return (\n        <div className='description'>\n            <h3 className='subheader'>The Harmonic Series in Music</h3>\n            <p>\n                Imagine you strike a string in a guitar.\n            </p>\n            <p>\n                Now, you are expecting to hear back a tone - the one that corresponds to the string. In reality, what we end up hearing is much more than that - it is a whole collection of tones. The collection starts with a low tone which is the intended one, and it's followed by a series of higher pitch tones that are relative to the initial tone.\n            </p>\n            <p>\n                Althought this is an infinite series, we can only hear a small subset of these tones.\n            </p>\n            <p>\n                These following tones are called harmonics or overtones\n            </p>\n\n            <h3 className='subheader'>Why does this happen?</h3>\n            \n            <p>\n                When we hit a string, the string starts bouncing up and down creating a vibration. The tone we are producing is dictated by the frequency at which the string is vibrating. This vibration is creating a series of sine waves - the first sine wave is one big wave bouncing through the whole string, the second one is of two waves, the third of three waves, and so on. All these different vibrations in the string are happening at the same time!\n            </p>\n            <p>\n                The tones produced by the string come from the wavelength of those sine waves - the first series has one long sine wave, it has the smallest frequency and therefore the lowest tone, and the following frequencies will come from the subsequent sine waves in the series which are getting smaller and smaller, therefore playing higher and higher tones.\n            </p>\n        </div>\n    )\n}\n\nexport default HarmonicSeriesDefinition;","const noteStrings: string[] = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n\nexport const noteFromPitch = (frequency: number) => {\n\tvar noteNum = 12 * (Math.log( frequency / 440 )/Math.log(2) );\n\treturn Math.round( noteNum ) + 69;\n}\n\nconst frequencyFromNoteNumber = (note: number) => {\n\treturn 440 * Math.pow(2,(note-69)/12);\n}\n\nconst centsOffFromPitch = (frequency: number, note: number) => {\n\treturn Math.floor( 1200 * Math.log( frequency / frequencyFromNoteNumber( note ))/Math.log(2) );\n}\n\nexport const detuneTypeFromPitch = (frequency: number, note: number) => {\n\tconst detune: number = centsOffFromPitch(frequency, note);\n\treturn detune === 0 ? '' : detune < 0 ? 'flat' : 'sharp';\n}\n\nexport const getNote = (noteNumber: number) => {\n    return noteStrings[noteNumber%12];\n}\n\nexport const autoCorrelate = (buf: Float32Array, sampleRate: number) => {\n\t// Implements the ACF2+ algorithm\n\tvar SIZE = buf.length;\n\tvar rms = 0;\n\n\tfor (var i=0;i<SIZE;i++) {\n\t\tvar val = buf[i];\n\t\trms += val*val;\n\t}\n\trms = Math.sqrt(rms/SIZE);\n\tif (rms<0.01) // not enough signal\n\t\treturn -1;\n\n\tvar r1=0, r2=SIZE-1, thres=0.2;\n\tfor (var j=0; j<SIZE/2; j++)\n\t\tif (Math.abs(buf[j])<thres) { r1=j; break; }\n\tfor (var x=1; x<SIZE/2; x++)\n\t\tif (Math.abs(buf[SIZE-x])<thres) { r2=SIZE-x; break; }\n\n\tbuf = buf.slice(r1,r2);\n\tSIZE = buf.length;\n\n\tvar c = new Array(SIZE).fill(0);\n\tfor (var y=0; y<SIZE; y++)\n\t\tfor (var z=0; z<SIZE-y; z++)\n\t\t\tc[y] = c[y] + buf[z]*buf[z+y];\n\n\tvar d=0; while (c[d]>c[d+1]) d++;\n\tvar maxval=-1, maxpos=-1;\n\tfor (var w=d; w<SIZE; w++) {\n\t\tif (c[w] > maxval) {\n\t\t\tmaxval = c[w];\n\t\t\tmaxpos = w;\n\t\t}\n\t}\n\tvar T0 = maxpos;\n\n\tvar x1=c[T0-1], x2=c[T0], x3=c[T0+1];\n\tconst a = (x1 + x3 - 2*x2)/2;\n\tconst b = (x3 - x1)/2;\n\tif (a) T0 = T0 - b/(2*a);\n\n\treturn sampleRate/T0;\n}","import { useEffect, useRef } from 'react'\n\ninterface SineWaveProps {\n    frequency: number\n    height: number\n    width: number\n    waves: number\n}\n\nconst SineWave = (props: SineWaveProps) => {\n\n    const GetColor = (): string => {\n        const element = document.getElementById(props.frequency.toString());\n        if (element === null) return 'white';\n        return window.getComputedStyle(element).color;\n    }\n\n    const canvasRef = useRef<HTMLCanvasElement | null>(null)\n    const contextRef = useRef<CanvasRenderingContext2D | null>(null)\n    let theta: number = 0;\n\n    useEffect(() => {\n        const canvas = canvasRef.current\n        if (canvas === null || canvasRef.current === null) return\n        canvas.width = props.width * 2\n        canvas.height = props.height * 2\n        canvas.style.width = `${props.width}px`\n        canvas.style.height = `${props.height}px`\n\n        const context = canvas.getContext('2d')\n        if (context === null) return\n        contextRef.current = context\n        draw();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [props.frequency, props.height, props.width])\n\n    const draw = () => {\n        \n        if (contextRef.current === null || canvasRef.current === null) return;\n        const context: CanvasRenderingContext2D = contextRef.current;\n        const canvas: HTMLCanvasElement = canvasRef.current;\n\n        context.clearRect(0, 0, canvas.width, canvas.height);\n        context.beginPath()\n        //context.moveTo(0, canvas.height / 2)\n\n        for (let i = 0; i < canvas.width; i++) {\n            const y: number = canvas.height / 2 + \n                Math.sin(i *\n                    0.0039 * props.waves /* wavelength, 0.39 is an arbitrary number that worked */ +\n                    0 /* increment, props.frequency would go here but I want to make it independent of it */) *\n                    50 /* amplitude */ *\n                    Math.sin(theta) /* speed */\n            context.lineTo(i, y);\n        }\n\n        context.lineWidth = 10\n        context.strokeStyle = GetColor();\n        context.stroke();\n\n        window.requestAnimationFrame(draw);\n        theta += 0.1; // speed\n    }\n\n    return (\n        <canvas\n            className='sine-wave'\n            ref={canvasRef}\n        />\n    )\n}\n\nexport default SineWave;","import { detuneTypeFromPitch, getNote, noteFromPitch } from \"../brains/AudioMath\";\nimport '../style/HarmonicSeriesNotes.css';\nimport SineWave from \"./SineWave\";\nimport * as Tone from 'tone'\n\n\ninterface HarmonicSeriesNotesProps {\n    frequency: number;\n}\n\ninterface HarmonicSeriesElement {\n    frequency: number;\n    note: string;\n}\n\nconst PlayTone = (synth: Tone.Synth, frequency: number) => {\n    // play for the duration of an 8th note\n    synth.triggerAttackRelease(frequency, \"8n\");    \n}\n\nconst HarmonicSeriesNotes = (props: HarmonicSeriesNotesProps) => {\n    if (props.frequency === 0) return null;\n\n    // create a synth and connect it to the main output (your speakers)\n    const synth = new Tone.Synth().toDestination();\n\n    const numberOfSeriesIterations: number = 8;\n    let harmonicSeriesElements: HarmonicSeriesElement[] = [];\n    let elementIteration: number = 0;\n\n    for (let seriesElem = 0; seriesElem < numberOfSeriesIterations; seriesElem++) {\n        const noteNumber = noteFromPitch(props.frequency * (seriesElem + 1));\n        const note = getNote(noteNumber % 12);\n        const detune = detuneTypeFromPitch(props.frequency, noteNumber);\n        const element: HarmonicSeriesElement = {\n            frequency: props.frequency * (seriesElem+1),\n            note: `${note} ${detune}`\n        };\n\n        harmonicSeriesElements[seriesElem] = element;\n    }\n\n    return(\n        <div className='harmonic-series'>\n        <h3>Your Harmonic Series</h3>\n        <div className='harmonic-table-container'>\n            <div>Frequency - Note</div>\n            <div className='wave-header'>Vibration of String</div>\n        </div>\n        {\n            harmonicSeriesElements.map(element => {\n                elementIteration++;\n                return (\n                    <div className='harmonic-element-container' key={element.frequency} onClick={() => PlayTone(synth, element.frequency)}>\n                        <div id={element.frequency.toString()}>{element.frequency} Hz - {element.note}</div>\n                        <div className='sine-wave'>\n                            <SineWave\n                                frequency={element.frequency}\n                                height={100}\n                                width={400}\n                                waves={elementIteration}\n                            />\n                        </div>\n                    </div>\n                );\n            })\n        }\n        </div>\n    )\n}\n\nexport default HarmonicSeriesNotes;","export default __webpack_public_path__ + \"static/media/SpeakerOn.4c640b39.svg\";","export default __webpack_public_path__ + \"static/media/SpeakerOff.4255cd4c.svg\";","import { useState } from 'react';\nimport '../style/NoteBanner.css'\nimport { cancelAudioStream, enableLiveInput } from '../brains/AudioSourcer';\nimport SpeakerOn from '../assets/SpeakerOn.svg'\nimport SpeakerOff from '../assets/SpeakerOff.svg'\n\ninterface NoteBannerProps {\n    note: string;\n    frequency: number;\n    updateNoteAndFrequency: (newNote: string, newFrequency: number) => void;\n}\n\nconst NoteBanner = (props: NoteBannerProps) => {\n    const [hasAudioStarted, setHasAudioStarted] = useState(false);\n    const [isHover, setIsHover] = useState(false);\n\n    const ToggleAudio = () => {\n        if (hasAudioStarted) {\n            cancelAudioStream();\n        }\n        else {\n            enableLiveInput(props.updateNoteAndFrequency);\n        }\n\n        setHasAudioStarted((hasAudioStarted) => !hasAudioStarted);\n    }\n\n    const getNoteString = (): string => {\n        if (props.frequency !== 0 || hasAudioStarted) {\n            return `${formattedFrequency} ${formattedNode}`\n        }\n\n        return 'To find your harmonic series, click here and play any sound'\n        \n    }\n\n    const getHoveredElement = (): JSX.Element | null => {\n        const speakerOnIcon = <img height='35px' width='35px' src={SpeakerOn} alt=\"Speaker is on\"/>\n        const speakerOffIcon = <img height='35px' width='35px' src={SpeakerOff} alt=\"Speaker is off\"/>\n\n        if (hasAudioStarted && isHover)\n            return hasAudioStarted ? speakerOnIcon : speakerOffIcon\n\n        if (!hasAudioStarted && isHover && props.frequency !== 0)\n            return speakerOffIcon\n        \n        return null;\n    }\n\n    const formattedFrequency = `${props.frequency} Hz`;\n    const formattedNode = props.note !== '' ? `- ${props.note.toString()}` : '';\n    return (\n        <div onClick={ToggleAudio} className='note-banner' onMouseEnter={() => setIsHover(true)} onMouseLeave={() => setIsHover(false)}>\n            {getNoteString()} {getHoveredElement()}\n        </div>\n    )\n}\n\nexport default NoteBanner;","import React from 'react';\nimport '../style/App.css';\nimport HarmonicSeriesDefinition from './HarmonicSeriesDefinition';\nimport HarmonicSeriesNotes from './HarmonicSeriesNotes';\nimport NoteBanner from './NoteBanner';\n\nconst App = () => {\n  const [frequency, setFrequency] = React.useState(0);\n  const [note, setNote] = React.useState('');\n\n  const updateNoteAndFrequency = (newNote: string, newFrequency: number) => {\n    setNote(newNote);\n    setFrequency(newFrequency);\n  }\n\n\n  return (\n    <div className=\"App\">\n        <HarmonicSeriesDefinition/>\n        <NoteBanner updateNoteAndFrequency={updateNoteAndFrequency} note={note} frequency={frequency}/>\n        <br></br>\n        <HarmonicSeriesNotes frequency={frequency}/>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './style/index.css';\nimport App from './components/App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}